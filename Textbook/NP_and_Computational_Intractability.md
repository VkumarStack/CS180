# NP and Computational Intractability
## Polynomial-Time Reductions
- When considering extremely hard computational problems, the notion of a **reduction** is useful to compare the relative difficulty of problems
- Consider problems *X* and *Y*, and suppose that there exists a **black box** that could solve instances of *X* in a single step
    - If arbitrary instances of *Y* could be solved in a polynomial number of standard computational steps and a polynomial number of calls to the black box for *X*, then *Y is polynomial-time reducible to X*
        - *Y ‚â§<sub>P</sub> X*
        - This implies that if there does exist a polynomial-time algorithm that solves *X*, then, by extension, there is also a polynomial-time algorithm time algorithm to solve *Y*
- If *Y ‚â§<sub>P</sub> X*, then if *Y* cannot be solved in polynomial time, then *X* also cannot be solved in polynomial time
### Independent Set and Vertex Cover
- In a graph *G = (V, E)*, a set of nodes *S ‚äÜ V* is independent if no two nodes in *S* are joined by an edge; the **Independent Set Problem** involves finding a large enough independent set in *G*
    - **Optimization version**: Find the maximum size of an independent set for *G*
        - Given a solution to the optimization version, the decision version can be solved 
    - **Decision version**: Determine whether or not (yes or no) *G* has an independent set of size at least *k*
        - Given a solution to the decision version, the optimization version can be solved (binary search for each *k* until the largest *k* is found)
    - ![Independent Set](../Images/Independent_Set_Vertex_Cover.png)
        - Largest independent set: {1, 4, 5, 6}
- In a graph *G = (V, E)*, a set of nodes *S ‚äÜ V* is a vertex cover if every edge *e in E* has at least one end in *S*; the **Vertex Cover Problem** also has a optimization and decision version akin to the Independent Set Problem, except now the goal is to get as small as a vertex cover as possible
    - ![Independent Set](../Images/Independent_Set_Vertex_Cover.png)
        - Smallest Vertex Cover: {2, 3, 7}
- It can be shown that the Independent Set Problem reduces into the Vertex Cover Problem and vice-versa: A set *S* is an independent set if and only if its complement *V - S* is a vertex cover
    - If *S* is an independent set, then an arbitrary edge *e = (u, v)* cannot both be in *S*, so one of them must be in *V - S*; this argument can be applied to every edge, implying that *V - S* is a vertex cover
        - A black box that solves the Decision Independent Set Problem can solve the Vertex Cover Problem by deciding whether *G* has an independent set of size at least *n - k*
    - If *V - S* is a vertex cover, then two nodes *u* and *v* in *S* cannot be joined by an edge *e* because neither of them would be in *V - S*, contradicting that it is a vertex cover - so *S* must be an independent set
        - A black box that solves the Decision Vertex Cover Problem can solve the Independent Set Problem by deciding whether *G* has a vertex cover of size at most *n - k*
### Set Cover and Set Packing
- A more general version of the Vertex Cover Problem is the Set Cover Problem: *Given a set U of n elements, a collection S<sub>1</sub>, ..., S<sub>m</sub> of subsets U, and a number k, does there exist a collection of at most k of these sets whose union is equal to U?*
    - ![Set Cover](../Images/Set_Cover.png)
    - The Vertex Cover Problem reduces to the Set Cover Problem: A black box that can solve the Set Cover Problem can be used to solve the Vertex Cover Problem
        - The set *U* is equal to *E* in the context of the graph, and each time a vertex *i* is chosen, all edges incident to it are added to a set *S<sub>i</sub>*
        - If sets *S<sub>i1</sub> ..., S<sub>il</sub>*, where *l <= k*, cover *U*, then every edge in *G* is incident to one of the vertices *i1, ..., il*, so the set of such vertices is a vertex cover in *G* of size *l <= k*
- A more general version of of the Independent Set Problem is the Set Packing Problem: *Given a set U of n elements, a collection S<sub>1</sub>, ..., S<sub>m</sub> of subsets U, and a number k, does there exist a collection of least k of these sets with the property that no two of them intersect?*
    - The reduction can be perofmred in the same way as the Vertex Cover Problem to Set Cover Problem
## Reduction via "Gadgets": The Satisfiability Problem
- Given a set *X* of *n Boolean variables x<sub>1</sub>, ..., x<sub>n</sub>*, a *term* over *X* is one of these variables *x<sub>i</sub>* or its negation *xÃÑ<sub>i</sub>*, and a *clause* of length *l* is a disjunction (an **OR**) of *l* distinct terms
    - *t<sub>1</sub> ‚à® t<sub>2</sub> ‚à® ... ‚à® t<sub>l</sub>*
- A truth assignment is a mapping of false (0) or true (1) to each *x<sub>i</sub>*; this means that *xÃÑ<sub>i</sub>* has the *opposite* truth value of *x<sub>i</sub>*
    - An assignment *satisfies* a clause *C* if it causes *C* to evaluate to true, and an assignment satisfies a collection of clauses *C<sub>1</sub>, ... , C<sub>k</sub>* if it causes all clauses to evaluate to true (an **AND**)
        - *C<sub>1</sub> ‚àß C<sub>2</sub> ‚àß ... ‚àß C<sub>k</sub>*
- The **Satisfiability Problem (SAT)**, another computationally hard problem, asks, *given a set of clauses C<sub>1</sub>, ..., C<sub>k</sub> over a set of variables X = {x<sub>1</sub>, ..., x<sub>n</sub>}, does there exist a satisfying truth assignment?*
    - The **3-SAT Problem** is concerned with clauses of length three
- It can be shown that the 3-SAT Problem can be reduced to the Independent Set Problem
    - This can be done by constructing a graph *G* consisting of *3k* nodes grouped into *k* triangles connected by edges such that a vertex *v<sub>ij</sub>* is the *j<sup>th</sup>* terms from clause *C<sub>i</sub>*
        - Additional edges are added for vertices whose labels correspond to terms that conflict (so the nodes corresponding to *x<sub>i</sub>* would form an edge with the nodes corresponding to *xÃÑ<sub>i</sub>*)
        - ![Independent Set SAT](../Images/Independent_Set_SAT.png)
    - If this resulting graph *G* possessed an independent set of size at least *k*, then the 3-SAT instance is satisfiable
        - If size of *S* is exactly *k*, it must consist of one node from each triangle (multiple nodes in the same triangle would imply that the set is not independent)
        - If one node in *S* were labeled *x<sub>i</sub>* and another were labeled *xÃÑ<sub>i</sub>*, then this would be a contradiction because there is an edge between the two nodes so *S* would not be independent
            - Only one of the two can appear as a label in *S*; if only *x<sub>i</sub>* appears, it should be set to true and otherwise only if *xÃÑ<sub>i</sub>* appears it should be set to false
            - Labels that don't appear in *S* can be arbitrarily set to true
        - In this way, it is ensured that all labels of nodes in *S* evaluate to 1, thus implying satisfiability
    - If the 3-SAT instance is satisfiable, then the resulting graph *G* has an independent set of size at least *k*
        - *S* must have one node from each triangle, and if there were an edge between two nodes *u, v* in *S*, then this would imply that their labels would have to conflict (since *u* and *v* cannot be from the same triangle), but this would contradict satisfiability since they must both evaluate to true
- Reductions are transitive, so:
    - *3-SAT ‚â§<sub>P</sub> Independent Set ‚â§<sub>P</sub> Vertex Cover ‚â§<sub>P</sub> Set Cover*
    - *3-SAT ‚â§<sub>P</sub> Set Cover*
## Efficient Certification and the Definition of NP
- For problems such as Independent Set and 3-SAT, it is hard to find polynomial-time algorithms to *solve* them; however, there are polynomial-time algorithms to *check* a proposed solution
    - For Independent Set, simply check that that no vertices in the proposed solution set have edges with each other
    - For 3-SAT, simply evaluate the clauses with respect to a proposed assignment of values to the terms
### Problems and Algorithms
- Consider the input, which can be encoded as a binary string *s* with length *|s|*, to a **decision problem**, represented by a set of strings *X* on which the answer is "yes"
    - An algorithm *A* for the decision problem *solves* *X* if, for all strings *s*, *A(s) = yes* if and only if *s* is in *X*
        - *A* has a *polynomial running time* if there is a polynomial function *p()* such that for every *s*, *A* is bounded by *O(p(|s|))*
        - ùí´ is the set of all problems *X* for which there exists an algorithm *A* with polynomial running time that solves *X*
### Efficient Certification
- An algorithm *B* is an *efficient certifier* for a problem *X* if it is a polynomial-time algorithm that takes the problem input *s* and a certificate string *t* and there is a polynomial function *p* so that for every string *s*, *s* is in *X* if and only if there exists a string *t* such that *|t| <= p(s)* and *B(s, t)*
    - *B* effectively tries to evaluate the proof *t* that *s* belongs to *X*, as long as *t* is not too long 
### NP: A Class of Problems
- ùí©ùí´ is the set of all problems for which an efficient certifier exists, and it can be observed that **ùí´ ‚äÜ ùí©ùí´**, since, if a polynomial-time algorithm to solve a problem exists, the certifier can simply output the result of that algorithm
- Although many computationally hard problems, such as 3-SAT, Independent Set, and Set Cover, belong to ùí©ùí´, there is no current proof that a problem in ùí©ùí´ does not belong to ùí´
    - The question of ùí´ = ùí©ùí´ is unknown, but is generally believed to be not true
## NP-Complete Problems
- A problem *X* is **NP-Complete** if (i) *X ‚àà ùí©ùí´* and (ii) for all *Y ‚àà ùí©ùí´*, Y ‚â§<sub>p</sub> X
    - If *X* is an NP-Complete problem, then it is solvable in polynomial time if and only if ùí´ = ùí©ùí´
        - If *X* can be solved in polynomial time, then any other ùí©ùí´ problem *Y* can be reduced to *X* and then solved in polynomial time as well
- To show that a problem is NP-Complete, it must be shown that the problem can encode *any* problem in ùí©ùí´
- One example of a problem in ùí©ùí´ is the **Circuit Satisfiability Problem**
    - Consider a circuit built out of gates implementing the standard boolean operations: ‚àß (AND), ‚à® (OR), and ¬¨ (NOT)
    - The circuit *K* is a directed acyclic graph where the *sources* are labeled with a constant boolean value (0 or 1) or a distinct variable (*inputs*), and every other nodes are labeled with boolean operators (directed either one node for NOT or two nodes for AND or OR)
    - The problem seeks, given a circuit *K*, whether there is an assignment to the inputs such that the circuit outputs true (1)
    - ![Circuit Satisfiability](../Images/Circuit_Satisfiability.png)
        - The circuit is satisfiable if the inputs (three on the bottom right) are 1, 0, and 1
- It has been shown that Circuit Satisfiability is NP-Complete, which can be intuitively justified by the fact that any algorithm that takes a fixed number of bits and produces a yes or no output can be represented as a circuit
    - The number of steps the algorithm takes is the size of the circuit (so a polynomial time algorithm corresponds to a polynomial size circuit)
    - To show that *X ‚â§<sub>p</sub> Circuit Satisfiability*, consider a black box that can solve Circuit Satisfiability
        - Since *X* is assumed to be in ùí©ùí´, it is known to have an efficient certifier *B*, which is a *polynomial-time algorithm*
        - *B* can be converted into a polynomial-size circuit with the first *n* sources being hard-coded with the values of the input to *X*, *s*, and the remaining *p(n)* sources being inputs labeled with the bits representing *t*, the certifier
        - With this setup, *s ‚àà X* if and only if there is a way to set the input bits to satisfy the circuit
        - Example Circuit: Given a graph *G*, does it contain a two-node independent set?
            - ![Circuit Satisfiability Independent Set](../Images/Circuit_Satisfiability_Independent_Set.png)
            - This circuit represents a graph of three nodes, *u, v, and w*, where *v* has an edge with both *u* and *w*
- If *Y* is an NP-Complete problem, and *X* is a problem in ùí©ùí´ with the property that *Y* ‚â§<sub>p</sub> *X*, then *X* is NP-Complete
- It can be shown that 3-SAT is NP-Complete by showing that Circuit Satisfiability can be reduced to 3-SAT 
    - Construction of Circuit:
        - If a node *v* in the circuit is ¬¨ and its entering edge is *u*, then it needs to be the case that *x<sub>v</sub> = xÃÑ<sub>u</sub>*, which can be guaranteed by adding the clauses *(x<sub>v</sub> ‚à® x<sub>u</sub>)* and *(xÃÑ<sub>v</sub> ‚à® xÃÑ<sub>u</sub>)*
        - If a node *v* in the circuit is ‚à® and its two entering edges are *u* and *w*, then it needs to be the case that *x<sub>v</sub> = x<sub>u</sub> ‚à® x<sub>v</sub>*, which can be guaranteed by adding the clauses  *(x<sub>v</sub> ‚à® xÃÑ<sub>u</sub>)*, *(x<sub>v</sub> ‚à® xÃÑ<sub>w</sub>)*, and *(xÃÑ<sub>v</sub> ‚à® x<sub>u</sub> ‚à® x<sub>w</sub>)*
        - If a node *v* in the circuit is ‚àß and its two entering edges are *u* and *w*, then it needs to be the case that *x<sub>v</sub> = x<sub>u</sub> ‚àß x<sub>v</sub>*, which can be guaranteed by adding the clauses  *(xÃÑ<sub>v</sub> ‚à® x<sub>u</sub>)*, *(xÃÑ<sub>v</sub> ‚à® x<sub>w</sub>)*, and *(x<sub>v</sub> ‚à® xÃÑ<sub>u</sub> ‚à® xÃÑ<sub>w</sub>)*
        - For sources that have a constant value, a single-variable clause of *x<sub>v</sub>* or *xÃÑ<sub>v</sub>* can be added to force the designated value, and for the output node *o*, a single-variable clause of *x<sub>o</sub>* can be added (requiring that *o* be 1)
    - If the given circuit *K* is satisfiable, then the satisfying assignments to the circuit inputs can be used to evaluate *all* nodes in the circuit, which can act as a solution to the constructed SAT instance
        - If the SAT instance constructed is satisfiable, then the values corresponding to the input variables of the circuit *K* can be used to satisfy *K*
    - The resulting *SAT* instance is not necessarily *3-SAT*, as some clauses possess only 1 or 2 terms
        - Clauses can be "extended" by adding four new terms *z<sub>1</sub>*, *z<sub>2</sub>*, *z<sub>3</sub>*, and *z<sub>4</sub>* such that *z<sub>1</sub> = z<sub>2</sub> = 0*
            - Add *(zÃÑ<sub>i</sub> ‚à® z<sub>3</sub> ‚à® z<sub>4</sub>)*, *(zÃÑ<sub>i</sub> ‚à® zÃÑ<sub>3</sub> ‚à® z<sub>4</sub>)*, *(zÃÑ<sub>i</sub> ‚à® z<sub>3</sub> ‚à® zÃÑ<sub>4</sub>)*, and *(zÃÑ<sub>i</sub> ‚à® zÃÑ<sub>3</sub> ‚à® zÃÑ<sub>4</sub>)* for *i = 1* and *i = 2*, which ensures that *z<sub>1</sub> = z<sub>2</sub> = 0* as otherwise all the clauses would not be satisfied
            - Clauses with only one term can have *z<sub>1</sub>* and *z<sub>2</sub>* added whereas clauses with two terms can have just *z<sub>1</sub>* added
    - Since *Circuit Satisfiability* can be reduced *3-SAT*, and *3-SAT* can be reduced into *Independent Set*, which can be reduced into *Vertex Cover*, which itself can be reduced into *Set Cover*, all these problems are *NP-Complete*
